<!DOCTYPE html><html lang="en">
<!-- Mirrored from bitcore.io/guides/i-made-this/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Dec 2018 16:42:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>i-made-this | Tutorials | Bitcore</title><meta name="description" content="Build a desktop application to timestamp files into the bitcoin blockchain with Bitcore."><!-- Twitter Card data--><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@BitPay"><meta name="twitter:title" content="i-made-this | Tutorials"><meta name="twitter:description" content="Build a desktop application to timestamp files into the bitcoin blockchain with Bitcore."><meta name="twitter:image" content="../../images/social/card.jpg"><!-- Open Graph data (Facebook and Reddit)--><meta property="og:title" content="i-made-this | Tutorials"><meta property="og:type" content="article"><meta property="og:url" content="../../index.html"><meta property="og:image" content="../../images/social/avatar.jpg"><meta property="og:description" content="Build a desktop application to timestamp files into the bitcoin blockchain with Bitcore."><meta property="og:site_name" content="Bitcore.io"><!-- Add to homescreen for Chrome on Android--><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="../../images/touch/chrome-touch-icon-192x192.b0c7306c.png"><!-- Add to homescreen for Safari on iOS--><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Bitcore"><link rel="apple-touch-icon-precomposed" href="apple-touch-icon-precomposed.html"><!-- Tile icon for Win8 (144x144 + tile color)--><meta name="msapplication-TileImage" content="../../images/touch/ms-touch-icon-144x144-precomposed.dcbb3eea.png"><meta name="msapplication-TileColor" content="#F9AB3D"><!-- Favicon--><link rel="shortcut icon" href="../../favicon.ico"><link rel="stylesheet" href="../../styles/main.88c254de.css" data-instant-track><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,300italic,400italic,600,700,700italic,600italic|Titillium+Web:400,300,700" rel="stylesheet" type="text/css"><script type="text/javascript" data-no-instant>
  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.0.1";
  if(this.location.host === 'bitcore.io'){ analytics.load('hP7mqqPCPPa5hRatDaulKFxm0kPiB6Es'); }
  else { analytics.load("dgbXyNcmHR3bJIjumdYoe3GZFrs6sHBd"); }
  }}();
</script>
<script data-no-instant>
  var $buoop = {vs:{i:9,f:30,o:25,s:5.1},c:2};
  function $buo_f(){
   var e = document.createElement("script");
   e.src = "../../../browser-update.org/update.js";
   document.body.appendChild(e);
  };
  try {document.addEventListener("DOMContentLoaded", $buo_f,false)}
  catch(e){window.attachEvent("onload", $buo_f)}
</script>
<meta name="google-site-verification" content="GOfbzCpKO__Imdru-L0nG1Fo9tTvyH3QVAIWsYO9rCk"></head><body class="bg-white"><nav class="navbar navbar-light bg-faded hidden-sm-down light-nav p-y-0"><div class="container"><div class="navbar p-l-0"><a href="../../index.html" title="Home" class="logo logo-dark margin-top"></a><ul class="nav navbar-nav pull-right"><li class="nav-item"><a href="../../start.html" class="nav-link">Getting Started</a></li><li class="nav-item"><a href="../index.html" class="nav-link active">Guides</a></li><li class="nav-item"><a href="../../bitcoin.html" class="nav-link">Bitcoin</a></li><li class="nav-item"><a href="../../api/index.html" class="nav-link">Docs</a></li><li class="nav-item"><a href="../../playground/index.html" class="nav-link">Playground        </a></li><li class="nav-item"><a href="http://forum.bitcore.io/" class="nav-link">Forum</a></li></ul></div></div></nav><div class="mobile-menu hidden-md-up"> <div id="exCollapsingNavbar" class="collapse"><div class="bg-inverse p-md"><h3 class="m-b-0"><ul class="p-l-0 no-bullets m-b-0"><li class="nav-item"><a href="../../index.html" class="nav-link">Home</a></li><li class="nav-item"><a href="../../start.html" class="nav-link">Getting Started</a></li><li class="nav-item"><a href="../index.html" class="nav-link active">Guides</a></li><li class="nav-item"><a href="../../bitcoin.html" class="nav-link">Bitcoin</a></li><li class="nav-item"><a href="../../playground/index.html" class="nav-link">Playground        </a></li><li class="nav-item"><a href="../../api/index.html" class="nav-link">Docs</a></li><li class="nav-item"><a href="http://forum.bitcore.io/" class="nav-link">Forum</a></li></ul></h3></div></div><nav class="navbar light-nav"><button type="button" data-toggle="collapse" data-target="#exCollapsingNavbar" class="navbar-toggler p-l-0"><div class="logo logo-square-orange menu-text">Menu</div></button></nav></div><div class="container"><div class="row"><div class="col-md-12 col-lg-3 m-t-lg"><h3 class="menu-header">Guides</h3><ul class="nav nav-pills nav-stacked"><li class="nav-item"><a href="../full-node/index.html" class="nav-link">Run a Full Node</a></li><li class="nav-item"><a href="../bitcoin/index.html" class="nav-link">Run Bitcoin Standalone</a></li><li class="nav-item"><a href="../upstart-daemon/index.html" class="nav-link">Run Bitcore as a Daemon</a></li><li class="nav-item"><a href="../wallet-service/index.html" class="nav-link">Run a Wallet Service</a></li><li class="nav-item"><a href="../browser.html" class="nav-link">Browser Builds</a></li></ul><h3 class="menu-header m-t-md">Tutorials</h3><ul class="nav nav-pills nav-stacked"><li class="nav-item"><a href="../service-development/index.html" class="nav-link">Service Development</a></li><li class="nav-item"><a href="../satoshi-fire-alarm/index.html" class="nav-link">Satoshi Fire Alarm</a></li><li class="nav-item"><a href="../lemonade-stand/index.html" class="nav-link">Lemonade Stand</a></li><li class="nav-item"><a href="index.html" class="active nav-link">I Made This</a></li></ul></div><div class="col-md-12 col-lg-9 m-t-lg docs"><h1 id="i-made-this">I Made This</h1>
<div id="i-made-this-container" align="center">
  <img src="../../images/guides/i-made-this/picturesinboxes-imadethis.aa58c7dc.jpg" />
  <p>
    Courtesy of <a href="http://www.picturesinboxes.com/2014/01/01/internet/">
      picturesinboxes
    </a>
  </p>
</div>

<p>In this tutorial, we will build a desktop app that timestamps original files into the blockchain by including their unique hashes as part of the <a href="http://bitcoin.stackexchange.com/questions/29554/explanation-of-what-an-op-return-transaction-looks-like">OP_RETURN</a> data of bitcoin transactions. The timestamps will serve as immutable proof that the files existed at a certain point in time, which can be used to demonstrate ownership of original content. You can <a href="https://github.com/bitpay/i-made-this">view the completed project files on GitHub</a>.</p>
<h4 id="how-it-works">How it works</h4>
<ol>
<li>The user uploads a file via the desktop app.</li>
<li>The app hashes the file and asks Bitcore node whether the file has already been timestamped in the blockchain.</li>
<li>If the file has not yet been timestamped, the app generates a new BTC address and displays that address to the user in the form of a QR code, prompting the user to send a small amount of BTC to that address.</li>
<li>Once the user&#39;s BTC arrives at the address, your Bitcore node utilizes the received bitcoin to broadcast a new transaction with the file hash included, serving as a permanent timestamp in the blockchain.</li>
</ol>
<h4 id="what-we-will-use">What we will use</h4>
<ol>
<li>A <a href="../../index.html">Bitcore</a> node to communicate with the blockchain</li>
<li>A custom Bitcore service to extend your Bitcore node so that it can timestamp files</li>
<li><a href="http://electron.atom.io/">Electron</a> and <a href="https://angularjs.org/">AngularJS</a> to serve as the Desktop UI to communicate with your Bitcore server. (The details of Electron and AngularJS will not be covered as part of this tutorial.)</li>
</ol>
<p>The final app will look like this:</p>
<div align="center">
  <img src="../../images/guides/i-made-this/screenshot.76141538.png" />
</div>


<h3 id="starting-your-project">Starting your project</h3>
<p>Create a new directory for your project:</p>
<pre><code>mkdir i-made-this
cd i-made-this

</code></pre><h3 id="setting-up-your-bitcore-node">Setting up your Bitcore node</h3>
<p>To set up your Bitcore node, <a href="../full-node/index.html">follow the instructions in this guide</a>. Be sure to configure your Bitcore node to run on <a href="https://en.bitcoin.it/wiki/Testnet">testnet</a> to avoid spending real bitcoins during development. Also, ensure you are running Node v0.12 or v4.2 LTS.</p>
<p>Start your new Bitcore node from within the newly created <code>mynode</code> directory (the start command must always be executed from within the <code>mynode</code> directory):</p>
<pre><code>cd mynode
bitcored
</code></pre><p>You should now see your Bitcore node begin to download the testnet blockchain (this can take up to 1 hour):</p>
<pre><code>[2015-10-21T22:53:25.974Z] info: Starting bitcoind
[2015-10-21T22:53:27.991Z] info: Bitcoin Daemon Ready
[2015-10-21T22:53:27.992Z] info: Starting db
[2015-10-21T22:53:28.004Z] info: Bitcoin Database Ready
[2015-10-21T22:53:28.005Z] info: Starting address
[2015-10-21T22:53:28.005Z] info: Starting web
[2015-10-21T22:53:28.040Z] info: Bitcore Node ready
[2015-10-21T22:53:29.994Z] info: Bitcoin Height: 16 Percentage: 0.000008310586963489186
[2015-10-21T22:53:30.999Z] info: Bitcoin Height: 64 Percentage: 0.00003177577309543267
[2015-10-21T22:53:32.002Z] info: Bitcoin Height: 112 Percentage: 0.000055240951041923836
</code></pre><h3 id="extending-your-bitcore-node-with-a-custom-service">Extending your Bitcore node with a custom service</h3>
<p>To create your custom Bitcore timestamping service, create a new <code>stampingservice</code> directory in your project root:</p>
<pre><code>cd ~/i-made-this
mkdir stampingservice
cd stampingservice
nano index.js
</code></pre><p>We will need several Node.js modules:</p>
<ul>
<li>async - For asynchronous workflows</li>
<li>levelup - Interface for storing data</li>
<li>leveldown - Bindings to LevelDB</li>
<li>mkdirp - Creating directories</li>
<li>bitcore-lib - For working with bitcoin data</li>
</ul>
<p>Install the dependencies to your <code>stampingservice</code> with:</p>
<pre><code>npm install async levelup leveldown mkdirp bitcore-lib --save
</code></pre><p>Place the following boilerplate code into <code>index.js</code>:</p>
<pre><code class="lang-javascript">var util = require(&#39;util&#39;);
var EventEmitter = require(&#39;events&#39;).EventEmitter;
var async = require(&#39;async&#39;);
var levelup = require(&#39;levelup&#39;);
var leveldown = require(&#39;leveldown&#39;);
var mkdirp = require(&#39;mkdirp&#39;);
var bitcore = require(&#39;bitcore-lib&#39;);
var BufferUtil = bitcore.util.buffer;
var Networks = bitcore.Networks;
var Block = bitcore.Block;
var $ = bitcore.util.preconditions;

function enableCors(response) {
  // A convenience function to ensure
  // the response object supports cross-origin requests
  response.set(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);
  response.set(&#39;Access-Control-Allow-Methods&#39;,&#39;POST, GET, OPTIONS, PUT&#39;);
  response.set(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept&#39;);
}

function StampingService(options) {
  EventEmitter.call(this);
  this.node = options.node;

  $.checkState(this.node.network, &#39;Node is expected to have a &quot;network&quot; property&#39;);
  this.network = this.node.network;

  this.log = this.node.log;
}
util.inherits(StampingService, EventEmitter);

StampingService.dependencies = [&#39;bitcoind&#39;];

StampingService.prototype.getAPIMethods = function(){
  return [];
}

StampingService.prototype.getPublishEvents = function(){
  return [];
}

StampingService.prototype.getRoutePrefix = function() {
  return &#39;stampingservice&#39;;
}

StampingService.prototype.start = function(callback) {
  setImmediate(callback);
}

StampingService.prototype.stop = function(callback) {
  setImmediate(callback);
}

module.exports = StampingService;
</code></pre>
<h4 id="checking-for-previous-timestamps">Checking for previous timestamps</h4>
<p>To check whether a file has been previously timestamped in the blockchain we need to add several methods to <code>index.js</code> to keep our database is sync with the bitcoin block chain. Because there can be block reorganizations where the chain can go into a different direction, we will need to make sure that all our operations are reversable. The effects of each block will commited to our database atomically. We can then connect and disconnect blocks into the chain.</p>
<p>We will need to be able to:</p>
<ul>
<li>Setup a LevelDB database</li>
<li>Record our current position in the chain</li>
<li>Parse a block for the data of interest, in this case OP_RETURN data</li>
<li>Connect a new block to the chain</li>
<li>Disconnect the current tip from the chain</li>
<li>Walk the chain, and verify it is continuous</li>
<li>Lookup the data that we&#39;ve stored</li>
</ul>
<p>To setup the LevelDB database, we will first establish the path of the database, with a helper method:</p>
<pre><code class="lang-javascript">StampingService.prototype._setDataPath = function() {
  $.checkState(this.node.services.bitcoind.spawn.datadir, &#39;bitcoind is expected to have a &quot;spawn.datadir&quot; property&#39;);
  var datadir = this.node.services.bitcoind.spawn.datadir;
  if (this.node.network === Networks.livenet) {
    this.dataPath = datadir + &#39;/bitcore-stamps.db&#39;;
  } else if (this.node.network === Networks.testnet) {
    if (this.node.network.regtestEnabled) {
      this.dataPath = datadir + &#39;/regtest/bitcore-stamps.db&#39;;
    } else {
      this.dataPath = datadir + &#39;/testnet3/bitcore-stamps.db&#39;;
    }
  } else {
    throw new Error(&#39;Unknown network: &#39; + this.network);
  }
};
</code></pre>
<p>And then call this function at construction and setup levelup, and other variables needed:</p>
<pre><code class="lang-javascript">function StampingService(options) {
  //...
  this._setDataPath();
  this.levelupStore = leveldown;
  if (options.store) {
    this.levelupStore = options.store;
  }
  //...
}
util.inherits(StampingService, EventEmitter);
</code></pre>
<p>And then in our start function, and some additional logic:</p>
<pre><code class="lang-javascript">StampingService.prototype.start = function(callback) {
  if (!fs.existsSync(this.dataPath)) {
    mkdirp.sync(this.dataPath);
  }

  this.store = levelup(this.dataPath, { db: this.levelupStore });
};
</code></pre>
<p>And some code to close the database on shutdown:</p>
<pre><code class="lang-javascript">StampingService.prototype.stop = function(callback) {
    self.store.close(callback);
};
</code></pre>
<p>We should now be able to open and close the levelup database to store our data.</p>
<p>Next we will go into how we can keep our database is sync with the blockchain. Let&#39;s start by
working on the method that will actually parse the block and store and remove the data. The blockHandler
method is included below. Add this method to <code>index.js</code>.</p>
<pre><code class="lang-javascript">StampingService.prototype.blockHandler = function(block, add, callback) {
  var self = this;

  var operations = [];

  // Update tip
  var tipHash = add ? new Buffer(block.hash, &#39;hex&#39;) : BufferUtil.reverse(block.header.prevHash);
  operations.push({
    type: &#39;put&#39;,
    key: StampingService.PREFIX_TIP,
    value: tipHash
  });

  var txs = block.transactions;
  var height = block.__height;

  // Loop through every transaction in the block
  var transactionLength = txs.length;
  for (var i = 0; i &lt; transactionLength; i++) {
    var tx = txs[i];
    var txid = tx.id;
    var outputs = tx.outputs;
    var outputScriptHashes = {};
    var outputLength = outputs.length;

    // Loop through every output in the transaction
    for (var outputIndex = 0; outputIndex &lt; outputLength; outputIndex++) {
      var output = outputs[outputIndex];
      var script = output.script;

      if(!script || !script.isDataOut()) {
        self.log.debug(&#39;Invalid script&#39;);
        continue;
      }

      // If we find outputs with script data, we need to store the transaction into level db
      var scriptData = script.getData().toString(&#39;hex&#39;);
      self.log.info(&#39;scriptData added to index:&#39;, scriptData);

      // Prepend a prefix to the key to prevent namespacing collisions
      // Append the block height, txid, and outputIndex for ordering purposes (ensures transactions will be returned
      // in the order they occured)
      var key = [StampingService.PREFIX, scriptData, height, txid, outputIndex].join(&#39;-&#39;);
      var value = block.hash;

      var action = add ? &#39;put&#39; : &#39;del&#39;;
      var operation = {
        type: action,
        key: key,
        value: value
      };

      operations.push(operation);
    }
  }

  self.log.debug(&#39;Updating the database with operations&#39;, operations);
  self.store.batch(operations, callback);
}
</code></pre>
<p>Now we will add two methods that will call <code>blockHandler</code>:</p>
<pre><code class="lang-javascript">StampingService.prototype.connectBlock = function(block, callback) {
  this.log.info(&#39;adding block&#39;, block.hash);
  this.blockHandler(block, true, callback);
};

StampingService.prototype.disconnectBlock = function(block, callback) {
  this.log.info(&#39;disconnecting block&#39;, block.hash);
  this.blockHandler(block, false, callback);
};

</code></pre>
<p>Now that we can add and remove blocks from the database, we need to be able to
get the current tip of the chain, and then connect and remove blocks from the chain.</p>
<p>First lets get the code to load and remove the tip of the chain.</p>
<p><strong>Note</strong>: Ideally to ensure that we always have access to the block data that we have
written, we would also keep a record of the latest blocks locally <em>(without relying on bitcoind)</em>.
Here we attempt several times and then give up.</p>
<pre><code class="lang-javascript">StampingService.prototype.loadTip = function(callback) {
  var self = this;

  var options = {
    keyEncoding: &#39;binary&#39;,
    valueEncoding: &#39;binary&#39;
  };

  self.store.get(StampingService.PREFIX_TIP, options, function(err, tipData) {
    if(err &amp;&amp; err instanceof levelup.errors.NotFoundError) {
      self.tip = self.genesis;
      self.tip.__height = 0;
      self.connectBlock(self.genesis, function(err) {
        if(err) {
          return callback(err);
        }

        self.emit(&#39;addblock&#39;, self.genesis);
        callback();
      });
      return;
    } else if(err) {
      return callback(err);
    }

    var hash = tipData.toString(&#39;hex&#39;);

    var times = 0;
    async.retry({times: 3, interval: self.retryInterval}, function(done) {
      self.node.getBlock(hash, function(err, tip) {
        if(err) {
          times++;
          self.log.warn(&#39;Bitcoind does not have our tip (&#39; + hash + &#39;). Bitcoind may have crashed and needs to catch up.&#39;);
          if(times &lt; 3) {
            self.log.warn(&#39;Retrying in &#39; + (self.retryInterval / 1000) + &#39; seconds.&#39;);
          }
          return done(err);
        }

        done(null, tip);
      });
    }, function(err, tip) {
      if(err) {
        self.log.warn(&#39;Giving up after 3 tries. Please report this bug to https://github.com/bitpay/bitcore-node/issues&#39;);
        self.log.warn(&#39;Please reindex your database.&#39;);
        return callback(err);
      }

      self.tip = tip;
      self.node.getBlockHeader(self.tip.hash, function(err, blockHeader) {
        if (err) {
          return callback(err);
        }
        if(!blockHeader) {
          return callback(new Error(&#39;Could not get height for tip.&#39;));
        }
        self.tip.__height = blockHeader.height;
        callback();
      });

    });
  });
};

</code></pre>
<p>This method then needs to be called when we start:</p>
<pre><code class="lang-javascript">StampingService.prototype.start = function(callback) {
  // ...
  self.loadTip(function(err) {
    if (err) {
      return callback(err);
    }
    self.emit(&#39;ready&#39;);
    callback();
  });
};
</code></pre>
<p>We now also need to be able to remove the tip:</p>
<pre><code class="lang-javascript">StampingService.prototype.disconnectTip = function(done) {
  var self = this;

  var tip = self.tip;

  // TODO: expose prevHash as a string from bitcore
  var prevHash = BufferUtil.reverse(tip.header.prevHash).toString(&#39;hex&#39;);

  self.node.getBlock(prevHash, function(err, previousTip) {
    if (err) {
      done(err);
    }

    // Undo the related indexes for this block
    self.disconnectBlock(tip, function(err) {
      if (err) {
        return done(err);
      }

      // Set the new tip
      previousTip.__height = self.tip.__height - 1;
      self.tip = previousTip;
      self.emit(&#39;removeblock&#39;, tip);
      done();
    });
  });
};
</code></pre>
<p>Next we need a function that will take our current tip and advance the chain and verify that the chain continues. In the case that the chain does not continue, we will remove the current tip, and the try to advance the chain again.</p>
<pre><code class="lang-javascript">StampingService.prototype.sync = function() {
  var self = this;

  if (self.bitcoindSyncing || self.node.stopping || !self.tip) {
    return;
  }

  self.bitcoindSyncing = true;

  var height;

  async.whilst(function() {
    if (self.node.stopping) {
      return false;
    }
    height = self.tip.__height;
    return height &lt; self.node.services.bitcoind.height;
  }, function(done) {
    self.node.getRawBlock(height + 1, function(err, blockBuffer) {
      if (err) {
        return done(err);
      }

      var block = Block.fromBuffer(blockBuffer);

      // TODO: expose prevHash as a string from bitcore
      var prevHash = BufferUtil.reverse(block.header.prevHash).toString(&#39;hex&#39;);

      if (prevHash === self.tip.hash) {

        // This block appends to the current chain tip and we can
        // immediately add it to the chain and create indexes.

        // Populate height
        block.__height = self.tip.__height + 1;

        // Create indexes
        self.connectBlock(block, function(err) {
          if (err) {
            return done(err);
          }
          self.tip = block;
          self.log.debug(&#39;Chain added block to main chain&#39;);
          self.emit(&#39;addblock&#39;, block);
          done();
        });
      } else {
        // This block doesn&#39;t progress the current tip, so we&#39;ll attempt
        // to rewind the chain to the common ancestor of the block and
        // then we can resume syncing.
        self.log.warn(&#39;Reorg detected! Current tip: &#39; + self.tip.hash);
        self.disconnectTip(function(err) {
          if(err) {
            return done(err);
          }
          self.log.warn(&#39;Disconnected current tip. New tip is &#39; + self.tip.hash);
          done();
        });
      }
    });
  }, function(err) {
    if (err) {
      Error.captureStackTrace(err);
      return self.node.emit(&#39;error&#39;, err);
    }

    if(self.node.stopping) {
      self.bitcoindSyncing = false;
      return;
    }

    self.node.isSynced(function(err, synced) {
      if (err) {
        Error.captureStackTrace(err);
        return self.node.emit(&#39;error&#39;, err);
      }

      if (synced) {
        self.bitcoindSyncing = false;
        self.node.emit(&#39;synced&#39;);
      } else {
        self.bitcoindSyncing = false;
      }
    });

  });

};
</code></pre>
<p>We now need to call the <code>sync</code> method when there is a new block and after we have loaded the chain tip from the database. We can do this by adding some code to the <code>start</code> method:</p>
<pre><code class="lang-javascript">StampingService.prototype.start = function(callback) {
  //...
  this.once(&#39;ready&#39;, function() {
    self.log.info(&#39;Bitcoin Database Ready&#39;);

    self.node.services.bitcoind.on(&#39;tip&#39;, function() {
      if(!self.node.stopping) {
        self.sync();
      }
    });
  });

  self.loadTip(function(err) {
    if (err) {
      return callback(err);
    }

    self.sync();
    self.emit(&#39;ready&#39;);
    callback();
  });
  //...
};
</code></pre>
<p>Now that the database will be kept in sync with the blockchain we can add a method to lookup the data stored.</p>
<p>The <code>lookupHash</code> method shown below will be called by the client-side code whenever a user uploads a file to
check whether that file has already been timestamped. This method will query the data that has
been stored by the blockHandler method above.</p>
<pre><code class="lang-javascript">StampingService.prototype.lookupHash = function(req, res, next) {
  /*
    This method is used to determine whether a file hash has
    already been included in the blockchain. We are querying data
    from level db that we previously stored into level db via the blockHanlder.
  */
  var self = this;
  enableCors(res);

  var hash = req.params.hash; // the hash of the uploaded file
  this.log.info(&#39;request for hash:&#39;, hash);
  var node = this.node;

  // Search level db for instances of this file hash
  // and put them in objArr
  var stream = self.store.createReadStream({
    gte: [StampingService.PREFIX, hash].join(&#39;-&#39;),
    lt: [StampingService.PREFIX, hash].join(&#39;-&#39;) + &#39;~&#39;
  });

  var objArr = [];

  stream.on(&#39;data&#39;, function(data) {
    // Parse data as matches are found and push it
    // to the objArr
    data.key = data.key.split(&#39;-&#39;);
    var obj = {
      hash: data.value,
      height: data.key[2],
      txid: data.key[3],
      outputIndex: data.key[4]
    };
    objArr.push(obj);
  });

  var error;

  stream.on(&#39;error&#39;, function(streamError) {
    // Handle any errors during the search
    if (streamError) {
      error = streamError;
    }
  });

  stream.on(&#39;close&#39;, function() {
    if (error) {
      return res.send(500, error.message);
    } else if(!objArr.length) {
      return res.sendStatus(404);
    }

    // For each transaction that included our file hash, get additional
    // info from the blockchain about the transaction (such as the timestamp and source address).
    async.each(objArr, function(obj, eachCallback) {
      var txid = obj.txid;
      var includeMempool = true;

      node.log.info(&#39;getting details for txid:&#39;, txid);
      node.getDetailedTransaction(txid, function(err, transaction) {
        if (err){
          return eachCallback(err);
        }
        var address = transaction.inputs[0].address;

        obj.sourceAddress = address;
        obj.timestamp = transaction.blockTimestamp;
        return eachCallback();
      });
    }, function doneGrabbingTransactionData(err) {
      if (err){
        return res.send(500, err);
      }

      // Send back matches to the client
      res.send(objArr);
    });

  });
}

</code></pre>
<h4 id="monitoring-btc-addresses">Monitoring BTC addresses</h4>
<p>To determine whether the user has sent BTC to the address generated by the desktop client, we&#39;ll add the following method to <code>index.js</code>:</p>
<pre><code class="lang-javascript">StampingService.prototype.getAddressData = function(req, res, next) {
  /*
    This method is called by the client to determine whether a BTC address
    has recieved funds yet
  */
  var self = this;
  enableCors(res);
  var address = req.params.address;
  this.node.getAddressUnspentOutputs(address, {}, function(err, unspentOutputs) {
    if (err){
      return self.log(&#39;err&#39;, err);
    }
    self.log.info(&#39;Address data (&#39; + address + &#39;):&#39;, unspentOutputs);
    res.send(unspentOutputs);
  });
}
</code></pre>
<h4 id="creating-transactions">Creating transactions</h4>
<p>To broadcast the transaction that includes the file hash, we need to add the following method to <code>index.js</code>:</p>
<pre><code class="lang-javascript">StampingService.prototype.sendTransaction = function(req, res, next){
  enableCors(res);
  var self = this;
  var serializedTransaction = req.params.transaction;

  this.node.sendTransaction(serializedTransaction, function(err) {
    if (err){
      self.log(&#39;error sending transaction&#39;, err);
      return res.send(500, err);
    }
    res.sendStatus(200);
  });
}
</code></pre>
<h4 id="registering-api-endpoints">Registering api endpoints</h4>
<p>In order for the client to query our custom Bitcore methods, we need to register those methods with Bitcore
by adding the following code to <code>index.js</code>:</p>
<pre><code class="lang-javascript">StampingService.prototype.setupRoutes = function(app) {
  app.get(&#39;/hash/:hash&#39;, this.lookupHash.bind(this));
  app.get(&#39;/address/:address&#39;, this.getAddressData.bind(this));
  app.get(&#39;/send/:transaction&#39;, this.sendTransaction.bind(this));
}
</code></pre>
<p>Symlink your <code>stampingservice</code> into the node_modules directory of <code>mynode</code>:</p>
<pre><code>cd ~/i-made-this/mynode/node_modules
ln -s ~/i-made-this/stampingservice
</code></pre><p>And symlink the <code>bitcore-lib</code> module, to a locally shared version for development:</p>
<pre><code>cd ~
git clone <a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="04636d7044636d706c71662a676b69">[email&#160;protected]</a>:bitpay/bitcore-lib.git
cd bitcore-lib
npm install --production
cd ~/i-made-this/stampingservice/node_modules
ln -s ~/bitcore-lib
</code></pre><p>Add <code>stampingservice</code> as a dependency in <code>mynode/bitcore-node.json</code>:</p>
<pre><code class="lang-json">{
  &quot;network&quot;: &quot;testnet&quot;,
  &quot;port&quot;: 3001,
  &quot;services&quot;: [
    &quot;bitcoind&quot;,
    &quot;web&quot;,
    &quot;stampingservice&quot; //add this
  ]
}
</code></pre>
<p>Restart your Bitcore node, and visit <a href="http://localhost:3001/stampingservice/hash/aCrAzYHaSh">http://localhost:3001/stampingservice/hash/aCrAzYHaSh</a> in your browser. If all went well, the server response will be &quot;Not Found&quot;, indicating that &#39;aCrAzYHaSh&#39; has never been included in the blockchain.</p>
<h2 id="wiring-the-client-side-app-to-your-bitcore-endpoints">Wiring the client-side app to your Bitcore endpoints</h2>
<p>Since the focus of this tutorial is Bitcore, only Bitcore-specific client-side code
will be covered. The rest of the client code can be viewed in the <a href="https://github.com/bitpay/i-made-this">project repository on GitHub</a>.</p>
<p>To install the Bitcore client-side library, run:
<code>bower install bitcore-lib --save</code></p>
<p>Include bitcore in your <code>index.e9e5e649.html</code> file via a script tag:</p>
<pre><code class="lang-html">&lt;script src=&quot;bower_components/bitcore-lib/bitcore-lib.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Then require Bitcore globally via:</p>
<pre><code class="lang-javascript">bitcore = require(&#39;bitcore-lib&#39;);
</code></pre>
<h4 id="hashing-the-uploaded-file">Hashing the uploaded file</h4>
<p>When a user uploads a file, we first need to hash the file client-side. This tutorial uses <a href="https://github.com/danialfarid/ng-file-upload">ng-file-upload</a>&#39;s
base64DataUrl to convert the file dataUrl to base64, which can then be used as an input to Bitcore&#39;s
Buffer class for hashing.</p>
<pre><code class="lang-javascript">function hashFile(file, cb){
  Upload.base64DataUrl(file).then(function(urls){
    var Buffer = bitcore.deps.Buffer;
    var data = new Buffer(urls, &#39;base64&#39;);
    var hash = bitcore.crypto.Hash.sha256sha256(data);
    var hashString = hash.toString(&#39;hex&#39;);
    return cb(hashString);
  });
}
</code></pre>
<p>After hashing the file and converting to a hex string, we are ready
to query our bitcore node to see if this file has already been stamped. In the code
below, we are sending a request to <a href="http://localhost:3001/stampingservice/hash/:fileHash">http://localhost:3001/stampingservice/hash/:fileHash</a>,
which will trigger the lookupHash method we&#39;ve configured on our Bitcore node:</p>
<pre><code class="lang-javascript">function isFileInBlockchain(fileHashString){
  // Asks bitcore-node if the hash of the uploaded file has been timestamped in
  // the blockchain before
  $http.get(bitcoreServiceBasePath + &#39;/hash/&#39; + fileHashString)
    .success(gotFile)

  function gotFile(data, statusCode){
    $scope.previousTimestamps = data;
    $scope.previousTimestamps = $scope.previousTimestamps.map(function(ts){
      // convert the integer timestamp to a date object for UI rendering
      ts.date = new Date(ts.timestamp*1000);
      return ts;
    });
  }

}
</code></pre>
<p>If the user chooses to timestamp the uploaded file, we&#39;ll need to generate
a new bitcoin address to which the user can send a small amount of Bitcoin, which will be used to fund the timestamping
transaction. An address can be generated with the following code:</p>
<pre><code class="lang-javascript">privateKey = new bitcore.PrivateKey();
var publicKey = new bitcore.PublicKey(privateKey);
$scope.address = new bitcore.Address(publicKey, bitcore.Networks.testnet).toString();
</code></pre>
<p>We can be notified when the user has sent funds to this address by polling
our Bitcore node via the <a href="#">http://localhost:3001/stampingservice/address/:address</a>
endpoint:</p>
<pre><code class="lang-javascript">function montiorAddress(address, cb){
  // Asks bitcore-node whether the input BTC address has received funds from the user
  function gotAddressInfo(data, statusCode){
    if(data.length){
      var unspentOutput = data[0];
      $interval.cancel(pollInterval);
      cb(unspentOutput);
    }
  }

  pollInterval = $interval(function(){
    console.log(&#39;montiorAddress interval called for address:&#39;, address);
    $http.get(bitcoreServiceBasePath + &#39;/address/&#39; + address)
      .success(gotAddressInfo)
  }, 1000); // poll every second
}
</code></pre>
<p>Once the user&#39;s BTC arrives at the generated address, we can now create a new transaction
to which we will attach the hash of the uploaded file.</p>
<pre><code class="lang-javascript">function timeStampFile(unspentOutput, privateKey){
  // Uses the BTC received from the user to create a new transaction object
  // that includes the hash of the uploaded file
  var UnspentOutput = bitcore.Transaction.UnspentOutput;
  var Transaction = bitcore.Transaction;
  var unspent2 = UnspentOutput(unspentOutput);

  // Let&#39;s create a transaction that sends all recieved BTC to a miner
  // (no coins will go to a change address)
  var transaction2 = Transaction();
  transaction2
    .from(unspent2)
    .fee(50000);

  // Append the hash of the file to the transaction
  transaction2.addOutput(new Transaction.Output({
    script: bitcore.Script.buildDataOut(fileHash, &#39;hex&#39;),
    satoshis: 0
  }));

  // Sign transaction with the original private key that generated
  // the address to which the user sent BTC
  transaction2.sign(privateKey);
  $scope.transactionId = transaction2.id;
  var serializedTransaction = transaction2.checkedSerialize();

  sendTransaction(serializedTransaction);
}

function sendTransaction(serializedTransaction){
  // Asks bitcore-node to broadcast the timestamped transaction
  $http.get(bitcoreServiceBasePath + &#39;/send/&#39; + serializedTransaction)
    .success(sentTransaction);

  function sentTransaction(){
    $scope.stampSuccess = true;
    pendingFileHashes[fileHash] = {date: new Date()};
  }
}
</code></pre>
<h2 id="the-end">The End</h2>
<p>That&#39;s it! Have questions about this tutorial? <a href="https://forum.bitcore.io/">Post them here</a>.
You can also <a href="https://github.com/bitpay/i-made-this">view the completed project files on GitHub</a>.</p>
</div></div></div><a class="exit-off-canvas"></a><script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="../../scripts/main.min.efe3021b.js" data-no-instant="data-no-instant"></script></body>
<!-- Mirrored from bitcore.io/guides/i-made-this/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Dec 2018 16:42:41 GMT -->
</html>